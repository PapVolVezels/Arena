/*Dit is een file voor alle functie's en macro's voor de communicatie tussen de stenen.
 *Kopiëer deze modules aan het begin van het programma. Je kunt daarna de functies gebruiken in het programma.
 *Bij sommige functies kun je één of meerdere parameters invoeren.
 *Alleen sub MotorX, sub MotorY en Commando werken met waardes, je voert de snelheid in die je wilt.
 */
 
 /*Niets hiervan is gecompiled, zit dus boordenvol beestjes!!!*/

//SLAVE&&MASTER

//Macro's
#define QUEUEMOTORX 1
#define QUEUEMOTORY 2
#define QUEUEPRESSURE 3
#define QUEUECOMMAND 4

//Connectiestatustask
task ConnectionStatus()
	{
		while(true)
			{
				ClearLine(LCD_LINE2);
				if (BluetoothStatus(CONNECTION) != NO_ERR)
					{
						TextOut(5,LCD_LINE2,"Bluetoetoeter!");
					}
				else
					{
						TextOut(5,LCD_LINE2,"BT working!");
					}
				Wait(10);
			}
	}

//MASTER

#define CONNECTION 1											//Vul gebruikte connectie in 
int sensortouchvalue;

//Klemmotor												//Stel de klemmotor (MotorX) in op de snelheid waarde vel
	void MotorX (int vel)										//"vel" staat voor de opgegeven snelheid
		{
			until(BluetoothStatus(CONNECTION) == NO_ERR);
			SendRemoteNumber(CONNECTION, QUEUEMOTORX, vel);
		}

//Gripmotor												//Stel de gripmotor (MotorY) in op snelheid waarde vel
	void MotorY (int vel)
		{
			until(BluetoothStatus(CONNECTION) == NO_ERR);
			SendRemoteNumber(CONNECTION, QUEUEMOTORY, vel);
		}

//Druksensor												//Lees de waarde van de Druksensor uit
	task DrukSensor ()
		{
			int tempvalue;
			char error;
			while(true)									//"value" staat voor de sensor waarde
				{
					until(BluetoothStatus(CONNECTION) == NO_ERR);
					error = ReceiveRemoteNumber(QUEUEPRESSURE, true, tempvalue);
					if(error == NULL)
						{
							sensortouchvalue = tempvalue;
						}
					Wait(10);
					
				}
		}

//SLAVE

#define CONNECTION 0											//Connectie van slave naar master is altijd 0
#define MOTORX OUT_A											//Vul hier de gebruikte poorten in
#define MOTORY OUT_B
#define SENSORTOUCH SENSOR_1
task main()
	{
		SetSensorTouch(S1);
	}

//Klemmotor
	void MotorX()											//Ontvang de verzochte snelheid voor de klemmotor (MotorX)
		{
			char error;
			int vel;									//"vel" en "value" betekenen hetzelfde als bij master
			until(BluetoothStatus(CONNECTION) == NO_ERR);
			error = ReceiveRemoteNumber(QUEUEMOTORX, true, vel);
			if(error == NULL)
				{
					OnFwd(MOTORX, vel);
				}
		}
	
//Gripmotor
	void MotorY()											//Ontvang de verzochte snelheid voor de klemmotor (MotorY)
		{
			char error;
			int vel;									//"vel" en "value" betekenen hetzelfde als bij master
			until(BluetoothStatus(CONNECTION) == NO_ERR);
			error = ReceiveRemoteNumber(QUEUEMOTORY, true, vel);
			if(error == NULL)
				{
					OnFwd(MOTORY, vel);
				}
		}

//Druksensor
	void DrukSensor()										//Stuur de waarde van Druksensor
		{
			int value;
			value = SENSORTOUCH;
			until(BluetoothStatus(CONNECTION) == NO_ERR);
			SendResponseNumber(QUEUEPRESSURE, value);
		}
